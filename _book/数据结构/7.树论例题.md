## 一般树题目集

### 1.橙子树

![image-20201208232151760](https://gitee.com/zisuu/picture/raw/master/img/20201208232151.png)

```
5 2
1 2 1
2 3 2
3 4 2
4 5 1


输出:
7
```

#### 题目分析

![image-20201208233503734](https://gitee.com/zisuu/picture/raw/master/img/20201208233503.png)

#### 算法选择

这里选择用dijkstra求最大路径长度

#### 代码实现

```c++
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> ll;
const int MAXN=1e5+10;
vector<ll> graph[MAXN];
vector<int> dist(MAXN,0);
vector<int> vis(MAXN,0);
priority_queue<ll,vector<ll>,less<ll>> qu; //优先队列
int sumL=0;//总的边权
int maxL=0; //离源点最大长度
void add(int a,int b,int v){
	graph[a].push_back({b,v});
	graph[b].push_back({a,v});
	sumL+=v;
}
void dijkstra(int start)
{
	qu.push({0,start});
	while(!qu.empty())
	{
		int cur=qu.top().second;
		qu.pop();
		if (vis[cur])continue;
		vis[cur]=true;
		maxL=max(maxL,dist[cur]);
		//对每一个邻接边
		for(int i=0;i<graph[cur].size();i++)
		{
			ll child= graph[cur][i];
			if(!vis[child.first])
			{
				if(dist[cur]+child.second>dist[child.first])
				{
					dist[child.first]=dist[cur]+child.second;
					qu.push({dist[child.first],child.first});
				}
			}
		}
	}
}
int main()
{
	int n,start;
	cin>>n>>start;
	int a,b,v;
	for(int i=0;i<n-1;i++)
	{
		cin>>a>>b>>v;
		add(a,b,v);
	}
	dijkstra(start);
	cout<<sumL*2-maxL;
}

```





## 二叉搜索树列题

### 1.地鼠安家

![image-20201208235416703](https://gitee.com/zisuu/picture/raw/master/img/20201208235416.png)

```
输入示例
5
-1 1 -1
1 2 3
-1 3 -1
2 4 5
-1 5 -1

输出:
3
```



#### 题目分析

考点:BST,BST中序遍历递增

先构建一棵树,利用中序遍历判断该序列是否递增即可



## 线状树列题

https://leetcode-cn.com/problems/range-sum-query-mutable/solution/java-xian-duan-shu-lazyyou-hua-jie-shi-hen-xiang-x/

#### [307. 区域和检索 ](https://leetcode-cn.com/problems/range-sum-query-mutable/)

![image-20201203170758373](https://gitee.com/zisuu/picture/raw/master/img/20201203170758.png)

## 字典树列题











