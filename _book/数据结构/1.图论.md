## 一  图的表示与遍历

### 1.邻接矩阵

![img](https://gitee.com/zisuu/picture/raw/master/img/20201128111757.jpeg)

### 2.邻接表

![img](https://gitee.com/zisuu/picture/raw/master/img/20201128111804.jpeg)

邻接表模板:

```
    typedef pair<int,int> ll;
    map<int,vector<ll>> graph;
    //初始化
    .....
    //
    for (int i=0;i<m;i++){
        cin>>a>>b>>value;
        graph[a].push_back({b,value});
        graph[b].push_back({a,value});
    }
```

### 3.dfs遍历

```
void DFS ( Vertex V ){
    visited[ V ] = true;
    for ( V 的每个邻接点 W )
        if( !visited[ W ])
            DFS( W );
}

```

### 4.bfs遍历

```
void BFS( Vertex V ){
    queue<Vertex> q;
    visited[V] = true;
    q.push(V);
    while(!q.empty()){
        V = q.front(); q.pop();
        for( V 的每个邻接点 W ){
        	if( !visited[ W ]){
            	visited[W] = true;
            	q.push(W);
            }
        }
    }
}

```



## 二 最短路算法

### 1.Dijkstra 算法  单源有权最短路

![image-20201128113037591](https://gitee.com/zisuu/picture/raw/master/img/20201128113037.png)

- 令 S = {源点s + 已经确定了最短路径的顶点 vi _i*i*}
- 对任一未收录的顶点 v，定义 dist[v] 为 s 到 v 的最短路径长度，但该路径仅经过 S 中的顶点。即路径 {s→(vi _i*i*∈S)→v} 的最小长度
- 若路径是按照递增（非递减）的顺序生成的，则
  - 真正的最短路必须只经过 S 中的顶点
  - 每次从未收录的顶点中选一个 dist 最小的收录
  - 增加一个 v 进入 S，可能影响另外一个 w 的 dist 值
    - dist[w] = min{dist[w],dist[v] + <v,w>的权重}

伪代码:

```
void Dijkstra( Vertex s ){
    while(1){
        V = 未收录顶点中dist最小值;
        if( 这样的V不存在 )
            break;
        collected[V] = true;
        for( V 的每个邻接点 W )
            if( collected[W] == false )
                if(dist[V] + E<V,W> < dist[W]){
             		dist[W] = dist[V] + E<V,W>;
                    path[W] = V;
                }
    }
}

```

堆优化版算法模板:(heap中的自动排序:先对第一个从小到大排序,若第一个相等,对第二个从小到大排序)

```
    int dijkstra(vector<vector<int>>& gh, int N, int K) {
        const int INF = 0x3f3f3f3f;
        typedef pair<int, int> PII; // first:距离; second: 几号点
        vector<bool> vis(N + 1, false); // 是否已得到最短距离
        vector<int> dist(N+1, INF); // 距离起始点的最短距离
        unordered_map<int, vector<PII>> graph; // 邻接表；u->v,权重w
        priority_queue<PII, vector<PII>, greater<PII>> heap; // 小顶堆；维护到起始点的最短距离和点

        for (auto &t: gh){ // 初始化邻接表
            graph[t[0]].push_back({t[2],t[1]});
        }
        
        heap.push({0, K});
        dist[K] = 0;
        while(heap.size()){
            auto t = heap.top();
            heap.pop();
            int ver = t.second, distance = t.first;
            if (vis[ver]) continue; // 之前更新过，是冗余备份
            vis[ver] = true;
            for (auto &p: graph[ver]){
                if (dist[p.second] > distance + p.first){ // 用t去更新其他点到起始点的最短距离
                    dist[p.second] = distance + p.first;
                    heap.push({dist[p.second], p.second});
                }
            }
        }
        int ans = *max_element(dist.begin()+1, dist.end());
        return ans == INF ? -1: ans;
    }
```



### 2.Floyd算法  多源最短路算法

实际上是动态规划的思想:

```
void Floyd(){
    for( k = 0; k < N; k++ )
        for( i = 0; i< N; i++)
            for( j = 0; j < N; j++ )
            	if( D[i][k] + D[k][j] < D[i][j] ) {
            		D[i][j] = D[i][k] + D[k][j];
                    path[i][j] = k;
                }
}

```

算法模板:

```
    int floyd(vector<vector<int>>& gh, int N, int K) {
        const int INF = 0x3f3f3f3f;
        vector<vector<int>> dist(N+1,vector<int>(N+1,INF));
        for (int i = 0; i <=N ; ++i) {
            dist[i][i]=0;
        }
        for(auto k:gh){
            dist[k[0]][k[1]]=min(dist[k[0]][k[1]],k[2]);
        }
        for (int k = 1; k <=N ; ++k) {
            for (int i = 1; i <=N ; ++i) {
                for (int j = 1; j <=N ; ++j) {
                    dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
                }
            }
        }
        int ans=0;
        for (int l = 1; l <=N ; ++l) {
            ans=max(ans,dist[K][l]);
        }
        return ans> INF/2?-1:ans;
    }
```



## 三 并查集

### 1.定义

如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：

![image-20201128114606903](https://gitee.com/zisuu/picture/raw/master/img/20201128114607.png)

现在我们的 Union-Find 算法主要需要实现这两个 API：



```
class UF {
    /* 将 p 和 q 连接 */
    public void union(int p, int q);
    /* 判断 p 和 q 是否连通 */
    public boolean connected(int p, int q);
    /* 返回图中有多少个连通分量 */
    public int count();
}
```

这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：

1、自反性：节点`p`和`p`是连通的。

2、对称性：如果节点`p`和`q`连通，那么`q`和`p`也连通。

3、传递性：如果节点`p`和`q`连通，`q`和`r`连通，那么`p`和`r`也连通。

比如说之前那幅图，0～9 任意两个**不同**的点都不连通，调用`connected`都会返回 false，连通分量为 10 个。

如果现在调用`union(0, 1)`，那么 0 和 1 被连通，连通分量降为 9 个。

再调用`union(1, 2)`，这时 0,1,2 都被连通，调用`connected(0, 2)`也会返回 true，连通分量变为 8 个。

![image-20201128114643714](https://gitee.com/zisuu/picture/raw/master/img/20201128114644.png)

如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上:

![image-20201128114730305](https://gitee.com/zisuu/picture/raw/master/img/20201128114730.png)

### 2.模板

```
class UnionFind{
public:
    int UnionNums;
    int *graph;
    /**
     * find
     */
    int find(int k){
        if(graph[k]==k)return k;
        else return k=find(graph[k]);
    }
    /**
     * union
     */
    void Union(int i,int j){
        int pI=find(i);
        int pK=find(j);
        if(pI!=pK){
            graph[pK]=pI;
            UnionNums--;
        }
    }
    
    //初始化
    UnionFind(int nums){
        UnionNums=nums;
        graph=new int[nums+1];
        for(int i=0;i<=nums;i++){
            graph[i]=i;
        }
    }
};
```



## 四 拓扑排序

### 1.定义

一共有 n 门课要上，编号为0 ~ n-1。先决条件[1, 0]，代表必须先上课 0，才能上课 1 。给你 n 和一个先决条件表，请你判断能否完成所有课程

生活的例子

- 先穿内裤再穿裤子，先穿打底再穿外套，先穿衣服再戴帽子，约定俗成
- 内裤外穿、光着身子戴帽等，都会有点奇怪
- 约束我们的一条条 先后规则，能否转成一串顺序行为——衣服是一件件穿的

引入有向图 描述依赖关系
示例：n = 6，先决条件表：[ [3, 0], [3, 1], [4, 1], [4, 2], [5, 3], [5, 4] ]
0, 1, 2 没有先修课，可以直接选。其余的，都要先修 2 门课
我们用 有向图 描述这种 依赖关系 (做事的先后关系)：

![微信截图_20200517052852.png](https://gitee.com/zisuu/picture/raw/master/img/20201128113430.png)



- 把这样一个 有向无环图 变成 线性的排序 就叫 拓扑排序
- 有向图 中有 入度 和 出度 概念：
- 如果存在一条有向边 A --> B，则这条边给 A 增加了 1 个出度，给 B 增加了 1 个入度

所以顶点 0、1、2 的 入度为 0。 顶点 3、4、5 的 入度为 2

解决问题的关键:

0.顺序是什么?

1.对于什么来说是有入度的,什么是出度

2.每次只能选入读为0的课进行收录

3.到最后如果还有一个课的入读不为0,则说明存在环形图

### 2.模板:

以上面提到的课程表为例子:

你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

 ![59410727664](https://gitee.com/zisuu/picture/raw/master/img/20201128113531.png)

```
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
     int len=numCourses;
     int in[len];
     int out[len];
     vector<vector<int>> ve;
     queue<int> q;
     vector<int> v;
     for(int i=0;i<len;i++){
         in[i]=out[i]=0;
         ve.push_back(v);
     }
     
     //构建拓扑序列
     for(int i=0;i<prerequisites.size();i++){
         int l1=prerequisites[i][0];
         int l2=prerequisites[i][1];
         ve[l2].push_back(l1);
         in[l1]++;
     }
     //将入度为0的放入队列
     for(int i=0;i<len;i++){
         if(in[i]==0)q.push(i);
     }
     int cnt=0;
     while(!q.empty()){
         int cur=q.front();
         q.pop();
         cnt++;
         //遍历当前节点的邻接表
         for(int i=0;i<ve[cur].size();i++){
             int c=ve[cur][i];
             in[c]--;
             if(in[c]==0)q.push(ve[cur][i]);
         }
     }
     return cnt==len;
}
};
```



## 五 最小生成树



### 0.定义

- **连通网**：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。
- **生成树**：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。
- **最小生成树**：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 
  ![这里写图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201128114949.png)

### 1.Prim算法

![img](https://gitee.com/zisuu/picture/raw/master/img/20201126142710.gif)

时间复杂度:

> Prim算法循环|V|-1∣V∣−1次, 使用线性扫描算法寻找最小值的时间复杂度为O(|V|^2+|E|), 
>
> 使用堆优化版Prim算法的时间复杂度是O(|E|log|V|)O(∣E∣log∣V∣).
>
> 

**算法模板:**(堆优化)

```c++
typedef pair<int,int> ll;
int prim( vector<vector<int>> graph, vector<int> dist,int n){
    priority_queue<ll,vector<ll>,greater<ll>> q;
    vector<bool> vis(n+1, false);
    dist[1]=0;
    int sum=0;
    q.push({dist[1],1});
    while( !q.empty() ){
        int index=q.top().second;
        q.pop();
        if(vis[index])continue;
        #加上这条边
        sum+=dist[index];
        vis[index]= true;
        #对其邻接边,收录
        for (int i = 1; i <=n ; ++i) {
            if(!vis[i] && graph[index][i]<dist[i] ){
                dist[i]=graph[index][i];
                q.push({dist[i],i});
            }
        }
    }
    for (int i = 1; i <= n ; ++i) {
        if(!vis[i])return -1;
    }
    return sum;
}
int main(){
    int n,m;
    cin>>n>>m;
    int inf=10000000;
    vector<int> dist(n+1,inf);
    vector<vector<int>> graph(n+1,vector<int>(n+1,inf));
    int a,b,value;
    for(int i=0;i<m;i++){
        cin>>a>>b>>value;
        graph[a][b]=value;
        graph[b][a]=value;
    }
    cout<<prim(graph,dist,n);
}
```

### 2.Kruskal 算法

![img](https://gitee.com/zisuu/picture/raw/master/img/20201126145815.gif)

> Kruskal算法是用于生成无向带权连通图的最小生成树的算法, 在Kruskal算法中将图中每个顶点看做一个独立的集合, 首先将图中的所有边按照权值进行从小到大排序, 并按此顺序枚举每条边, 如果这条边的两个端点不属于同一个集合(连通分量), 那么将两个集合合并(并查集算法), 同时将这条边加入边集合E'E 
> , 直到所有的顶点都属于同一个集合时, E'E 
> 就是MST.
> Kruskal是一种贪心算法, 对于未选择的边权最小的边(u, v)(u,v), 如果加上这条边后图中出现了一个环, 则不符合树的性质, 则不选择该边.

算法模板: 

```c++
#include <bits/stdc++.h>
using namespace std;
struct Edge{
    int a,b,w;
    Edge(int a,int b ,int w):a(a),b(b),w(w){}
    bool operator < (Edge o)const{
        return w<o.w;
    }
};
vector<Edge> g;
vector<int> fa;
int find(int x){
    return x==fa[x]?x:fa[x]=find(fa[x]);
}
int kruskal(int n){
    //对边进行排序
    sort(g.begin(),g.end());
    int ans=0;
    int cnt=n;
    for(Edge e:g){
        int fax= find(e.a);
        int fay= find(e.b);
        if(fax!=fay){
            //计数
            cnt--;
            //合并
            fa[fax]=fay;
            //加上这条边的值
            ans+=e.w;
        }
    }
    return cnt==1?ans:-1;
}
int main(){
    int n,m;
    cin>>n>>m;
    int a,b,value;
    fa=vector<int>(n+1,0);
    for (int i = 1; i <=n ; ++i) {
        fa[i]=i;
    }
    for(int i=0;i<m;i++){
        cin>>a>>b>>value;
        g.push_back(Edge(a,b,value));
    }
    cout<<kruskal(n);
}
```



## 六 二分图

### 1.定义

**二分图**：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 UU 和VV ，使得每一条边都分别连接UU、VV中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。

**匹配**：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。

![image-20201128211716041](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20201128211716041.png)

我们定义**匹配点**、**匹配边**、**未匹配点**、**非匹配边**，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。

**最大匹配**：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。

**完美匹配**：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。

举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是**完美匹配**问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是**最大匹

![](https://gitee.com/zisuu/picture/raw/master/img/20201128211742.png)

### 2.匈牙利算法

![image-20201128211749443](https://gitee.com/zisuu/picture/raw/master/img/20201128211749.png)

**交替路**：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。

**增广路**：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：

![image-20201128211755161](https://gitee.com/zisuu/picture/raw/master/img/20201128211755.png)

增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是**改进匹配**。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。

我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。

**匈牙利树**一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树：

![image-20201128211806384](https://gitee.com/zisuu/picture/raw/master/img/20201128211806.png)

这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。

下面给出**匈牙利算法**的 DFS 和 BFS 版本的代码：

```cpp
// 顶点、边的编号均从 0 开始
// 邻接表储存

struct Edge
{
    int from;
    int to;
    int weight;

    Edge(int f, int t, int w):from(f), to(t), weight(w) {}
};

vector<int> G[__maxNodes]; /* G[i] 存储顶点 i 出发的边的编号 */
vector<Edge> edges;
typedef vector<int>::iterator iterator_t;
int num_nodes;
int num_left;
int num_right;
int num_edges;
int matching[__maxNodes]; /* 存储求解结果 */
int check[__maxNodes];

bool dfs(int u)
{
    for (iterator_t i = G[u].begin(); i != G[u].end(); ++i) { // 对 u 的每个邻接点
        int v = edges[*i].to;
        if (!check[v]) {     // 要求不在交替路中
            check[v] = true; // 放入交替路
            if (matching[v] == -1 || dfs(matching[v])) {
                // 如果是未盖点，说明交替路为增广路，则交换路径，并返回成功
                matching[v] = u;
                matching[u] = v;
                return true;
            }
        }
    }
    return false; // 不存在增广路，返回失败
}

int hungarian()
{
    int ans = 0;
    memset(matching, -1, sizeof(matching));
    for (int u=0; u < num_left; ++u) {
        if (matching[u] == -1) {
            memset(check, 0, sizeof(check));
            if (dfs(u))
                ++ans;
        }
    }
    return ans;
}
queue<int> Q;
int prev[__maxNodes];
int Hungarian()
{
    int ans = 0;
    memset(matching, -1, sizeof(matching));
    memset(check, -1, sizeof(check));
    for (int i=0; i<num_left; ++i) {
        if (matching[i] == -1) {
            while (!Q.empty()) Q.pop();
            Q.push(i);
            prev[i] = -1; // 设 i 为路径起点
            bool flag = false; // 尚未找到增广路
            while (!Q.empty() && !flag) {
                int u = Q.front();
                for (iterator_t ix = G[u].begin(); ix != G[u].end() && !flag; ++ix) {
                    int v = edges[*ix].to;
                    if (check[v] != i) {
                        check[v] = i;
                        Q.push(matching[v]);
                        if (matching[v] >= 0) { // 此点为匹配点
                            prev[matching[v]] = u;
                        } else { // 找到未匹配点，交替路变为增广路
                            flag = true;
                            int d=u, e=v;
                            while (d != -1) {
                                int t = matching[d];
                                matching[d] = e;
                                matching[e] = d;
                                d = prev[d];
                                e = t;
                            }
                        }
                    }
                }
                Q.pop();
            }
            if (matching[i] != -1) ++ans;
        }
    }
    return ans;
}
```

**匈牙利算法的要点如下**

1. 从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。
   1. 如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。
   2. 如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。
2. 由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 `prev` 数组。

**性能比较**

两个版本的时间复杂度均为O(V⋅E)O(V⋅E)。DFS 的优点是思路清晰、代码量少，但是性能不如 BFS。我测试了两种算法的性能。对于稀疏图，BFS 版本明显快于 DFS 版本；而对于稠密图两者则不相上下。在完全随机数据 9000 个顶点 4,0000 条边时前者领先后者大约 97.6%，9000 个顶点 100,0000 条边时前者领先后者 8.6%, 而达到 500,0000 条边时 BFS 仅领先 0.85%。

补充定义和定理：

**最大匹配数**：最大匹配的匹配边的数目

**最小点覆盖数**：选取最少的点，使任意一条边至少有一个端点被选择

**最大独立数**：选取最多的点，使任意所选两点均不相连

**最小路径覆盖数**：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。

定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理）

定理2：最大匹配数 = 最大独立数

定理3：最小路径覆盖数 = 顶点数 - 最大匹配数



























