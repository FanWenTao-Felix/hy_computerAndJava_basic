###  

## 报头

![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\20180901092556271.png)

```
源/目的端口号: 表示数据是从哪个进程来, 到哪个进程去;
32位序号/32位确认号: 不一定从0开始（作用：保证确认应答；保证数据按序到达；去重）
4位TCP报头长度: 表示该TCP头部有多少个32位bit(有多少个4字节); 所以TCP报头最大长度是15 * 4 = 60 字节
6位标志位:
    1. URG: 紧急指针是否有效
    2. ACK: 确认号是否有效
    3. PSH: 提示接收端应用程序立刻从TCP缓冲区把数据读走
    4. RST: 对方要求重新建立连接; 我们把携带RST标识的称为复位报文段
    5. SYN: 请求建立连接; 我们把携带SYN标识的称为同步报文段
    6. FIN: 通知对方, 本端要关闭了, 我们称携带FIN标识的为结束报文段
16位窗口大小: 接收缓冲区剩余的空间大小 
16位校验和: 发送端填充, CRC校验. 接收端校验不通过, 则认为数据有问题. 此处的检验和不光包含TCP 首部, 也包含TCP数据部分. 
16位紧急指针: 标识哪部分数据是紧急数据; 12345678910111213
```

## 特点

### 1.面向连接

![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\20180901094250499.png)



> ### 三次握手过程理解
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\20180717202520531.png)
>
>  
>
> 第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入**SYN_SENT**状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
>
> 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入**SYN_RECV**状态；
>
> 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入**ESTABLISHED**（TCP连接成功）状态，完成三次握手。
>
> ### 四次挥手过程理解
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\20180717204202563.png)
>
> 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
> 2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
> 3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
> 4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
> 5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
> 6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
>
> ### 常见面试题
>
> 【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？
>
> 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
>
> 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
>
> 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
>
> 【问题3】为什么不能用两次握手进行连接？
>
> 答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
>
> ​       现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。
>
> 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？
> TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。



### 3.可靠传输

序列号 确认应答 超时重传 拥塞控制

#### 1.确认应答机制&序列号

TCP将每个字节的数据都进行了编号，即为序列号。
每一个ACK都带有对应的确认序列号，意思是告诉发送者，我已经收到了哪些数据;；下一次你从哪里开始发。

#### 2.超时重传&序列号

主机A发送数据给B之后, 可能因为网络拥堵等原因, 数据无法到达主机B; 如果主机A在一个特定时间间隔内没有收到B发来的确认应答, 就会进行重发;
主机A未收到B发来的确认应答，也可能是因为ACK丢失了，因此主机B会收到很多重复数据.。那么TCP协议需要能够识别出那些包是重复的包,，并且把重复的丢弃掉.，这时候我们可以利用序列号, 就可以很容易做到去重的效果。

#### 3.拥塞控制

在某段时间，若**对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏**，这种情况就叫做**网络拥塞**。

在计算机网络中数位链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。

若**出现拥塞而不进行控制**，整个网络的**吞吐量将随输入负荷的增大而下降**。
拥塞控制, 归根结底是TCP协议想尽可能快的把数据传输给对方, 但是又要避免给网络造成太大压力的折中方案。

**提高传输效率：**滑动窗口、流量控制、延迟应答、捎带应答

##### ****



##### 延迟应答

如果接收数据的主机立刻返回ACK应答, 这时候返回的窗口可能比较小.
窗口越大, 网络吞吐量就越大, 传输效率就越高. 我们的目标是在保证网络不拥塞的情况下尽量提高传输效率;

##### **捎带应答**

在延迟应答的基础上, 我们发现, 很多情况下, 客户端服务器在应用层也是 “一发一收” 的.
意味着客户端给服务器说了 “How are you”, 服务器也会给客户端回一个 “Fine, thank you”; 那么这个时候ACK就可以搭顺风车, 和服务器回应的 “Fine, thank you” 一起回给客户端。

#### 4.流量控制

### 4.面向字节流：**

创建一个TCP的socket, 同时在内核中创建一个发送缓冲区和一个接收缓冲区；
另一方面, TCP的一个连接, 既有发送缓冲区, 也有接收缓冲区, 那么对于这一个连接, 既可以读数据, 也可以写数据. 这个概念叫做 全双工 。

1. 调用write时, 数据会先写入发送缓冲区中;
2. 如果发送的字节数太长, 会被拆分成多个TCP的数据包发出; 如果发送的字节数太短, 就会先在缓冲区里等待, 等到缓冲区长度差不多了, 或者其他合适的时机发送出去;
3. 接收数据的时候, 数据也是从网卡驱动程序到达内核的接收缓冲区;
4. 然后应用程序可以调用read从接收缓冲区拿数据;

### **5.TCP粘包问题**

1. 首先要明确, 粘包问题中的 “包” , 是指的应用层的数据包；
2. 在TCP的协议头中, 没有如同UDP一样的 “报文长度” 这样的字段, 但是有一个序号这样的字段；
3. 站在传输层的角度, TCP是一个一个报文过来的，按照序号排好序放在缓冲区中；
4. 站在应用层的角度, 看到的只是一串连续的字节数据. 那么应用程序看到了这么一连串的字节数据, 就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包。

**那么如何避免粘包问题呢?**
**归根结底就是一句话, 明确两个包之间的边界.**

1.对于定长的包, 保证每次都按固定大小读取即可;
2.对于变长的包, 可以在报头的位置, 约定一个包总长度的字段, 从而就知道了包的结束位置;
3.对于变长的包, 还可以在包和包之间使用明确的分隔符。
4.TLV格式的数据传输

### 6TCP异常情况

1. 进程终止: 进程终止会释放文件描述符, 仍然可以发送FIN. 和正常关闭没有什么区别.
2. 机器重启: 和进程终止的情况相同
3. 机器掉电/网线断开: 接收端认为连接还在, 一旦接收端有写入操作, 接收端发现连接已经不在了, 就会进行 reset. 即使没有写入操作, TCP自己也内置了一个保活定时器, 会定期询问对方方是否还在. 如果对方不在, 也会把连接释放

## 3.协议

HTTP
HTTPS
SSH
Telnet
FTP
SMTP

## 4.性能

### 4.1 滑动窗口

> 概述
>
> 滑动窗口实现了TCP流控制。首先明确**滑动窗口**的范畴：TCP是双工的协议，会话的双方都可以同时接收和发送数据。TCP会话的双方都各自维护一个`发送窗口`和一个`接收窗口`。各自的`接收窗口`大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的`发送窗口`则要求取决于对端通告的`接收窗口`，要求相同。
>
> 滑动窗口解决的是**流量控制**的的问题，就是如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。接收端的缓存传输数据给应用层，但这个过程不一定是即时的，如果发送速度太快，会出现接收端数据overflow，流量控制解决的是这个问题。
>
> ## 窗口的概念
>
> 发送方的发送缓存内的数据都可以被分为4类:
> \1. 已发送，已收到ACK
> \2. 已发送，未收到ACK
> \3. 未发送，但允许发送
> \4. 未发送，但不允许发送
>
> 其中类型2和3都属于发送窗口。
>
> 接收方的缓存数据分为3类：
> \1. 已接收
> \2. 未接收但准备接收
> \3. 未接收而且不准备接收
>
> 其中类型2属于接收窗口。
>
> 窗口大小代表了设备一次能从对端处理多少数据，之后再传给应用层。缓存传给应用层的数据不能是乱序的，窗口机制保证了这一点。现实中，应用层可能无法立刻从缓存中读取数据。
>
> ## 滑动机制
>
> 1. 发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界。
>
> 2. 接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。
>
> 3. 遵循快速重传、累计确认、选择确认等规则。
>
> 4. 发送方发的window size = 8192;就是接收端最多发送8192字节，这个8192一般就是发送方接收缓存的大小。
>
> 5. 累计确认原则
>
>    > 面试问题：TCP的可靠性，超时重传怎么实现，M1,M2,M3,M4,M5，丢失M2；怎么重传M2？为什么不用重传M4,M5？
>    >
>    > 因为每个TCP报文被发送时，都会设置一个重传定时器，若定时期到了还没收到ack包，则应重传。为什么不用重传M4,M5？则可由[此文](https://blog.csdn.net/wdscq1234/article/details/52476231)回答：因为采用了累积确认。有例如下：
>    >
>    > 1. Server 发送80个字节 Part1，seq = 1
>    > 2. Server 发送120个字节Part2，Seq = 81
>    > 3. Server发送160个字节Part3，Seq = 201，此包由于其他原因丢失
>    > 4. Client收到前2个报文段，并发送ACK = 201
>    > 5. Server发送140个字节Part4， Seq = 361
>    > 6. Server收到Client对于前两个报文段的ACK，将2个报文从窗口中移除，窗口有200个字节的余量
>    > 7. 报文3的重传定时器到期，没有收到ACK，进行重传
>    > 8. 这个时候Client已经收到报文4，存放在缓冲区中，也不会发送ACK【累计通知，发送ACK就表示3也收到了】，等待报文3，报文3收到之后，一块对3,4进行确认
>    > 9. Server收到确认之后，将报文3,4移除窗口，所有数据发送完成
>
> ## 模拟动画
>
> ### 模拟特点
>
> 找到了一个模拟TCP窗口发送的[动画的地址](http://www.exa.unicen.edu.ar/catedras/comdat1/material/Filminas3_Practico3.swf)，稍微有缺陷：1. 丢包率如果设得太高，有时无论重发多少次都不能恢复正常 2. 窗口最大可为10，其实应该为9
>
> 明确发送端和接收端，发送A~S数据包，我们不会从头到尾分析，因为过程比较长。
> \1. 简化了窗口大小，双方窗口大小都一直是4
> \2. 设置一定的丢包率，否则没什么值得分析的，包括sender发送的数据包和receiver回复的ACK包。
> \3. 简化重传机制，出现丢包则直接重传，不等3个冗余ACK和超时。
> \4. 既不是选择重传也不是退回N步，重传的包是随机的
> 发
>
> ### 分析滑动窗口机制
>
> 1. 首先发送端发送A,B,C,D四个包，但是A,B丢失，只有C,D到达接收端。
>    ![img](https://c1.staticflickr.com/1/955/42138740462_ed4ce64c1b_b.jpg)
> 2. 接收端没有收到A，所以不回复ACK包。发送端重传A,B,C,D四个包，这次全都到达了。
>    ![img](https://c1.staticflickr.com/1/949/42138740402_dbbbf52c8c_b.jpg)
> 3. 接收端先获得A，发ACK包A，但是中途丢失；获得B后，根据累计确认的原则，发D的ACK包，然后窗口滑动。再次获得C,D后，连续回复2个D的ACK包，其中C对应的ACK包丢失。
>    ![img](https://c1.staticflickr.com/1/904/27313728687_a5673da755_b.jpg)
> 4. 发送端连收2个D的ACK包，说明4个包对方都已收到，窗口滑动，发E,F,G,H包，其中G包丢失。现在整个序列的状态：ABCD是已发送已确认，EFGH是已发送未确认，I~S是不能发送。
>    ![img](https://c1.staticflickr.com/1/951/27313728577_04e0867716_b.jpg)
> 5. 接收端先收到E，发ACK包；收到F后发F的ACK包；未收到G，还是发F的ACK包；收到H，还是发F的ACK包。不幸的是，三个ACK包全都丢失。
>    ![img](https://c1.staticflickr.com/1/952/27313728427_a5b7d4b107_b.jpg)
> 6. 发送端收到E的ACK包，窗口向右滑动一位；然后再发送F,G,H,I，其中F丢失。
>    ![img](https://c1.staticflickr.com/1/944/27313728297_65698014e9_b.jpg)
> 7. 接收端获得I，因为没有G，只好回复F的ACK包。相继收到G,H包。
>    ![img](https://c1.staticflickr.com/1/973/28312507728_96c5813bee_b.jpg)
> 8. 接收端根据累计确认，连发两个I包，其中H对应的丢失。窗口向右滑动。
>    ![img](https://c1.staticflickr.com/1/824/41284211495_31f906941b_b.jpg)
> 9. 发送端接收I的ACK包后，向右滑动四位。发送J,K,L,M四个包，后面不再分析。
>    ![img](https://c1.staticflickr.com/1/976/27313728077_b406cc3293_b.jpg)
>
> 从上面的过程中，我们可以得到以下结论：
> \1. TCP连接是通过数据包和ACK实现的，我们作为第三者可以看到双方发包的过程，但接受者在收到之前不知道发送方发的是什么，同样的，发送方在收到ACK前也不知道对方是否成功接收。
>
> 1. 发送方没有收到接收方发回的ACK，就不能向右滑动。假设发送方向接收方发了ABCD就滑动，只要对方没收到A，就不能滑动，那么就会出现二者不同步的局面。
> 2. 滑动窗口提高了信道利用率，TCP是发送报文段为单位的，假如每发一个报文就要等ACK，那么对于大数据包，等待时间就太长了。只要发送的报文在滑动窗口里面，不用等每个ACK回来就可以向右滑动。本例中，开始接收端空着AB，只有CD，此时不能滑动；之后接收到EF和H，直接向右滑动2位，不必等G到位。
> 3. 窗口大小不能大于序号空间大小的一半。目的是为了不让两个窗口出现交迭，比如总大小为7，窗口大小都为4，接收窗口应当滑动4，但只剩3个序号，导致两个窗口交迭。
> 4. 有一种情况没出现：发送方发ABCD，接收方都收到然后向右滑动，但回复的ACK包全丢了。发送方未收到任何ACK， timeout后会重发ABCD，此时的接收方按累计确认的原则，收到ABCD后只会重发D的ACK，发送方收到后向右滑动。

### 4.2.拥塞控制

> 在某段时间，若**对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏**，这种情况就叫做**网络拥塞**。
>
> 在计算机网络中数位链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。
>
> 若**出现拥塞而不进行控制**，整个网络的**吞吐量将随输入负荷的增大而下降**。
> ![在这里插入图片描述](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\20190731190238241.png)
> 当输入的负载到达一定程度 吞吐量不会增加，即一部分网络资源会丢失掉，网络的吞吐量维持在其所能控制的最大值，转发节点的缓存不够大这造成分组的丢失是拥塞的征兆。
> **TCP的四种拥塞控制算法**
> 1.慢开始
> 2.拥塞避免
> 3.快重传
> 4.快恢复
> **假定**：
> 1.数据是单方向传送，而另一个方向只传送确认
> 2.接收方总是有足够大的缓存空间，因而发送发发送窗口的大小由网络的拥塞程度来决定
> 3.以TCP报文段的个数为讨论问题的单位，而不是以字节为单位
> ![在这里插入图片描述](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\20190731155254165.png)
> **示例如下：**
> 传输轮次：发送方给接收方发送数据报文段后，接收方给发送方发回相应的确认报文段，一个传输轮次所经历的时间就是往返时间RTT(RTT并非是恒定的数值），使用传输轮次是为了强调，把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个报文段的确认，拥塞窗口cwnd会随着网络拥塞程度以及所使用的拥塞控制算法动态变化。
>
> 在tcp双方建立逻辑链接关系时， 拥塞窗口cwnd的值被设置为1，还需设置慢开始门限ssthresh,在执行慢开始算法时，发送方每收到一个对新报文段的确认时，就把拥塞窗口cwnd的值加一，然后开始下一轮的传输，当拥塞窗口cwnd增长到慢开始门限值时，就使用拥塞避免算法。
>
> **慢开始：**
> 假设当前发送方拥塞窗口cwnd的值为1，而发送窗口swnd等于拥塞窗口cwnd，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2，
>
> > 发送方此时可以连续发送两个数据报文段，接收方收到该数据报文段后，给发送方一次发回2个确认报文段，发送方收到这两个确认报文后，将拥塞窗口的值加2变为4，发送方此时可连续发送4个报文段，接收方收到4个报文段后，给发送方依次回复4个确认报文，发送方收到确认报文后，将拥塞窗口加4，置为8，发送方此时可以连续发送8个数据报文段，接收方收到该8个数据报文段后，给发送方一次发回8个确认报文段，发送方收到这8个确认报文后，将拥塞窗口的值加8变为16，
>
> 当前的拥塞窗口cwnd的值已经等于慢开始门限值，之后改用拥塞避免算法。
>
> **拥塞避免：**
> 也就是每个传输轮次，拥塞窗口cwnd只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口cwnd按指数增长。同理，16+1……直至到达24，假设24个报文段在传输过程中丢失4个，接收方只收到20个报文段，给发送方依次回复20个确认报文段，一段时间后，丢失的4个报文段的重传计时器超时了，发送发判断可能出现拥塞，更改cwnd和ssthresh.并重新开始慢开始算法，如图所示：
> ![在这里插入图片描述](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\20190731165743903.png)![在这里插入图片描述](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\20190731165605396.png)
> **快速重传：**
> 发送方发送1号数据报文段，接收方收到1号报文段后给发送方发回对1号报文段的确认，在1号报文段到达发送方之前，发送方还可以将发送窗口内的2号数据报文段发送出去，接收方收到2号报文段后给发送方发回对2号报文段的确认，在2号报文段到达发送方之前，发送方还可以将发送窗口内的3号数据报文段发送出去，
>
> > 假设该报文丢失，发送方便不会发送针对该报文的确认报文给发送方，发送方还可以将发送窗口内的4号数据报文段发送出去，接收方收到后，发现这不是按序到达的报文段，因此给发送方发送针对2号报文段的重复确认，表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而收到了未按序到达的报文段，发送方还可以将发送窗口中的5号报文段发送出去,接收方收到后，发现这不是按序到达的报文段，因此给发送方发送针对2号报文段的重复确认，表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而收到了未按序到达的报文段,，发送方还可以将发送窗口内的最后一个数据段即6号数据报文段发送出去，接收方收到后，发现这不是按序到达的报文段，因此给发送方发送针对2号报文段的重复确认，表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而收到了未按序到达的报文段，
>
> 此时，发送方收到了累计3个连续的针对2号报文段的重复确认，立即重传3号报文段，接收方收到后，给发送方发回针对6号报文的确认，表明，序号到6为至的报文都收到了，这样就不会造成发送方对3号报文的超时重传，而是提早收到了重传。
> ![在这里插入图片描述](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\20190731184314574.png)
> ![在这里插入图片描述](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\20190731184640178.png)
>
> ![在这里插入图片描述](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\20190731184935595.png)

### 4.3流量控制

> 大家可能都听说过拥塞控制和流量控制，想必也有一些人可能还分不清拥塞控制和流量控制，进而把他们当作一回事。拥塞控制和流量控制虽然采取的动作很相似，但拥塞控制与网络的拥堵情况相关联，而流量控制与接收方的缓存状态相关联。
>
> 也就是说，拥塞控制和流量控制是针对完全不同的问题而采取的措施。今天这篇文章，我们先来讲讲拥塞控制。
>
> **一、为何要进行拥塞控制？**
>
> 为了方便，我们假设主机A给主机B传输数据。
>
> 我们知道，两台主机在传输数据包的时候，如果发送方迟迟没有收到接收方反馈的ACK，那么发送方就会认为它发送的数据包丢失了，进而会重新传输这个丢失的数据包。
>
> 然而实际情况有可能此时有太多主机正在使用信道资源，导致网络拥塞了，而A发送的数据包被堵在了半路，迟迟没有到达B。这个时候A误认为是发生了丢包情况，会重新传输这个数据包。
>
> 结果就是不仅浪费了信道资源，还会使网络更加拥塞。因此，我们需要进行拥塞控制。
>
> **二、如何知道网络的拥塞情况？**
>
> A与B建立连接之后，就可以向B发送数据了，然而这个时候A并不知道此时的网络拥塞情况如何，也就是说，A不知道一次性连续发送多少个数据包好，我们也把A一次性连续发送多少个数据包称之为拥塞窗口，用N代表此时拥塞窗口的大小吧。
>
> 为了探测网络的拥塞情况，我们可以采取以下两种策略：
>
> 1、先发送一个数据包试探下，如果该数据包没有发生超时事件(也就是没有丢包)。那么下次发送时就发送2个，如果还是没有发生超时事件，下次就发送3个，以此类推，即N = 1, 2, 3, 4, 5.....
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\640.webp)
>
> ​                *(图可能画的不大形象，，，，)*
>
> 2、一个一个增加实在是太慢了，所以可以刚开始发送1个，如果没有发生超时时间，就发送2个，如果还是没有发送超时事件就发送4个，接着8个...，用翻倍的速度类推,即 N = 1, 2, 4, 8, 16...
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\640.webp)
>
> 无论是第一种方法还是第二种方法，最后都会出现瓶颈值。不过这里值得注意的是，第一种情况的增长速率确实有点慢，但是第二种情况以指数增长，增长速度有点太快了，可能一下子就到瓶颈值了。
>
> 为了解决这个过慢或过快的问题，我们可以把第一种方法和第二种方法结合起来。也就是说，我们刚开始可以以指数的速度增长，增长到某一个值，我们把这个值称之为阈值吧，用变量ssthresh代替。当增长到阈值时，我们就不在以指数增长了，而是一个一个线性增长。
>
> 所以最终的策略是：前期指数增长，到达阈值之后，就以一个一个线性的速度来增长。
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\640.webp)
>
> *(注：8之后其实是直线的，那里只是弯曲了一下)*
>
> 我们也把指数增长阶段称之为慢启动，线性增长阶段称之为拥塞避免
>
> **三、到了瓶颈值之后怎么办？**
>
> 无论是指数增长还是一个一个增长，最终肯定会出现超时事件，总不可能无限增长吧。当出现超时事件时，我们就认为此时网络出现了拥塞了，不能再继续增长了。我们就把这个时候的N的值称之为瓶颈值吧，用MAX这个字母来代替吧，即最大值。
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\640.webp)
>
> *注：这里再次提醒阈值过后是一个一个线性增长，图中之所以弯曲是因为我画图原因导致的。*
>
> 当达到最大值MAX之后，我们该怎么办呢？
>
> 当到达最大值之后我们采取的策略是这样的：
>
> 我们就回到最初的最初的状态，也就是说从1，2，4，8.....开始,不过这个时候我们还会把ssthresh调小，调为MAX值的一半，即ssthresh = MAX / 2。
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\640.webp)
>
> 图中阈值为8，瓶颈值是14；超时事件发生后，阈值为14 / 2 = 7。
>
> **四、超时事件就一定是网络拥塞？**
>
> 超时事件发送就一定是网络出现了拥堵吗？其实也有可能不是出现了网络拥堵，有可能是因为某个数据包出现了丢失或者损害了，导致了这个数据包超时事件发生了
>
> 为了防止这种情况，我们是通过冗余ACK来处理的。我们都知道，数据包是有序号的，如果A给B发送M1, M2, M3, M4, M5...N个数据包，如果B收到了M1, M2, M4....却始终没有收到M3，这个时候就会重复确认M2，意在告诉A,M3还没收到，可能是丢失了。
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\640.webp)
>
> 当A连续收到了三个确认M2的ACK，且M3超时事件还没发生。A就知道M3可能丢失了，这个时候A就不必等待M3设置的计时器到期了，而是快速重传M3。并且把ssthresh设置为MAX的一半，即ssthresh = MAX/2，但是这个时候并非把控制窗口N设置为1，而是让N = ssthresh，N在一个一个增长。
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\640-1597893172670.webp)
>
> 我们也把这种情况称之为快速恢复。而这种具有快速恢复的TCP版本称之为TCP Reno。
>
> 还有另外一种TCP版本，无论是收到三个相同的ACK还是发生超时事件，都把拥塞窗口的大小设为1，从最初状态开始，这种版本的TCP我们称之为TCP Tahoe。
>
> **一、为什么需要流量控制?**
>
>  
>
> 双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来，这时候接收方只能把处理不过来的数据存在缓存区里（失序的数据包也会被存放在缓存区里）。
>
>  
>
> 如果缓存区满了发送方还在疯狂着发送数据，接收方只能把收到的数据包丢掉，大量的丢包会极大着浪费网络资源，因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。
>
>  
>
> 对发送方发送速率的控制，我们称之为流量控制。
>
>  
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\640-1597658260483.jfif)
>
>  
>
> **二、如何控制?**
>
>  
>
> 接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为接收窗口大小，用变量win来表示接收窗口的大小。
>
>  
>
> 发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发生。
>
>  
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\640-1597658260487.jfif)
>
>  
>
>  
>
>  
>
> **三、发送方何时再继续发送数据?**
>
>  
>
> 当发送方停止发送数据后，该怎样才能知道自己可以继续发送数据？
>
>  
>
> 我们可以采用这样的策略：当接收方处理好数据，接受窗口 win > 0 时，接收方发个通知报文去通知发送方，告诉他可以继续发送数据了。当发送方收到窗口大于0的报文时，就继续发送数据。
>
>  
>
> 不过这时候可能会遇到一个问题，假如接收方发送的通知报文，由于某种网络原因，这个报文丢失了，这时候就会引发一个问题：接收方发了通知报文后，继续等待发送方发送数据，而发送方则在等待接收方的通知报文，此时双方会陷入一种僵局。
>
>  
>
> 为了解决这种问题，我们采用了另外一种策略：当发送方收到接受窗口 win = 0 时，这时发送方停止发送报文，并且同时开启一个定时器，每隔一段时间就发个测试报文去询问接收方，打听是否可以继续发送数据了，如果可以，接收方就告诉他此时接受窗口的大小；如果接受窗口大小还是为0，则发送方再次刷新启动定时器。
>
>  
>
> ![img](D:\Typora\java核心\操作系统,计算机网络\计算机网络\assets\640-1597658260516.jfif)
>
>  
>
>  
>
> **四、一些术语及其注意点说明**
>
>  
>
> 1、这里说明下，由于TCP/IP支持全双工传输，因此通信的双方都拥有两个滑动窗口，一个用于接受数据，称之为接收窗口；一个用于发送数据，称之为拥塞窗口(即发送窗口)。指出接受窗口大小的通知我们称之为窗口通告。
>
>  
>
> **2、接收窗口的大小固定吗？**
>
>  
>
> 在早期的TCP协议中，接受接受窗口的大小确实是固定的，不过随着网络的快速发展，固定大小的窗口太不灵活了，成为TCP性能瓶颈之一，也就是说，在现在的TCP协议中，接受窗口的大小是根据某种算法动态调整的。
>
>  
>
> **3、接受窗口越大越好吗？**
>
>  
>
> 接受窗口如果太小的话，显然这是不行的，这会严重浪费链路利用率，增加丢包率。那是否越大越好呢？答否，当接收窗口达到某个值的时候，再增大的话也不怎么会减少丢包率的了，而且还会更加消耗内存。所以接收窗口的大小必须根据网络环境以及发送发的的拥塞窗口来动态调整。
>
>  
>
> **4、发送窗口和接受窗口相等吗？**
>
>  
>
> 接收方在发送确认报文的时候，会告诉发送发自己的接收窗口大小，而发送方的发送窗口会据此来设置自己的发送窗口，但这并不意味着他们就会相等。首先接收方把确认报文发出去的那一刻，就已经在一边处理堆在自己缓存区的数据了，所以一般情况下接收窗口 >= 发送窗口。
>
>  
>
> 我这篇文章算是可以让你知道流量控制的大致原理，如果你想知道更多细节，可以参考TCP/IP详解这本书，挺不错。文章若有错误，还望后台留言指点下，谢谢。