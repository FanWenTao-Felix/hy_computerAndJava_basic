## 一般树题目集

### 1.橙子树

![image-20201208232151760](https://gitee.com/zisuu/picture/raw/master/img/20201208232151.png)

```
5 2
1 2 1
2 3 2
3 4 2
4 5 1


输出:
7
```

**题目分析**

![image-20201208233503734](https://gitee.com/zisuu/picture/raw/master/img/20201208233503.png)

**算法选择**

这里选择用dijkstra求最大路径长度

**代码实现**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> ll;
const int MAXN=1e5+10;
vector<ll> graph[MAXN];
vector<int> dist(MAXN,0);
vector<int> vis(MAXN,0);
priority_queue<ll,vector<ll>,less<ll>> qu; //优先队列
int sumL=0;//总的边权
int maxL=0; //离源点最大长度
void add(int a,int b,int v){
	graph[a].push_back({b,v});
	graph[b].push_back({a,v});
	sumL+=v;
}
void dijkstra(int start)
{
	qu.push({0,start});
	while(!qu.empty())
	{
		int cur=qu.top().second;
		qu.pop();
		if (vis[cur])continue;
		vis[cur]=true;
		maxL=max(maxL,dist[cur]);
		//对每一个邻接边
		for(int i=0;i<graph[cur].size();i++)
		{
			ll child= graph[cur][i];
			if(!vis[child.first])
			{
				if(dist[cur]+child.second>dist[child.first])
				{
					dist[child.first]=dist[cur]+child.second;
					qu.push({dist[child.first],child.first});
				}
			}
		}
	}
}
int main()
{
	int n,start;
	cin>>n>>start;
	int a,b,v;
	for(int i=0;i<n-1;i++)
	{
		cin>>a>>b>>v;
		add(a,b,v);
	}
	dijkstra(start);
	cout<<sumL*2-maxL;
}

```

### 2.[不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

![image-20201210193431504](https://gitee.com/zisuu/picture/raw/master/img/20201210193431.png)

**题目分析**

本题主要考察dp,bst的性质

以i为根节点,则其左子树为[0,i-1],右子树为[i+1,n]

所以num[i]=dp[i-1]+dp[n-i] (i=0,1,2,....n);

dp边界是dp[0]=1

代码:

```c++
class Solution {
public:
int numTrees(int n) {
    vector<int> dp(n+1,0);
    dp[0]=1;
    for (int i = 1; i <=n ; ++i) {
        for(int j=1;j<=i;j++){
            dp[i]+=dp[j-1]*dp[i-j];
        }
    }
    return dp[n];
}
};
```



## 树的递归类型

### 0.[二叉树展开为链表⭐](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

![image-20201210201547921](https://gitee.com/zisuu/picture/raw/master/img/20201210201548.png)

**题目分析**

递归的常见思路:

- 相信一个函数,能提供将以root为根的树,展开为链表
- 于是我们可以借助此函数得到左右两根链表
- 最后变化一下即可
- 一定要把递归想象成一个抽象的过程,就当作我们已经有两根链表了,要做的无非是遍历到左边那根链表的最右边那个节点,然后把右边那根链表接上即可

```c++
class Solution {
public:
typedef TreeNode * node;
node dfs(node root){
    if(!root)return NULL;
    node left=dfs(root->left);
    node right=dfs(root->right);
    root->right=left;
    //遍历到最右边一个节点
    node temp=root;
    while(temp->right){
        temp=temp->right;
    }
    temp->right=right;
    root->left=NULL;
    return root;
}
void flatten(TreeNode* root) {
    dfs(root);
}
};
```

### 1.[验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

![image-20201210194838614](https://gitee.com/zisuu/picture/raw/master/img/20201210194838.png)

对于BST,无非左子树比当前小,右子树比当前大,逃不过这个性质,关于BST的都可以往这个方向套

所以,很容易得出递归的思路:

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
typedef TreeNode * node;
bool  dfs(node root,long lower,long upper){
    if(!root)return true;
    int val=root->val;
    if(val<=lower||val>=upper)return false;
    return dfs(root->left,lower,val)&&dfs(root->right,val,upper);

}
bool isValidBST(TreeNode* root) {
    return dfs(root,LONG_MIN,LONG_MAX);
}
};
```

### 2.[路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

![image-20201210201156416](https://gitee.com/zisuu/picture/raw/master/img/20201210201156.png)

**题目分析**

这是一道很常见的dfs回朔类型的题目

```c++
struct TreeNode{
	int val;
	TreeNode * left;
	TreeNode * right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
typedef TreeNode * node;
vector<vector<int>> result;
void dfs(node root,int cur,vector<int> arr)
{
	if(!root)return;
	int val=root->val;
	cur-=val;
	arr.push_back(val);
	if (!root->left&&!root->right&&cur==0)
	{
		result.push_back(arr);
		//注意回朔 
		arr.pop_back();
		return;
	}
	dfs(root->left,cur,arr);
	dfs(root->right,cur,arr);
			//注意回朔 
	arr.pop_back();
}
vector<vector<int>> pathSum(TreeNode* root, int sum) {
    dfs (root,sum,vector<int>{});
    return result;
}
```

### 3.[二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

![image-20201210204108512](https://gitee.com/zisuu/picture/raw/master/img/20201210204108.png)

![image-20201210204116338](https://gitee.com/zisuu/picture/raw/master/img/20201210204116.png)

**题目分析**

同样根据第一题的思路:

- 相信一个函数dfs,它可以返回以root为根节点的最大路径
- 也即我们就可以得到左右两颗树各自的最大路径,那对于当前节点root,其最大路径就是left+cur+right,并更新答案
- 但是返回的,是左右最大的路径+cur,而不是返回最大路径

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
typedef TreeNode * node;
int answer=INT_MIN;
int dfs(node root)
{
	if (!root)return 0;
	int left=dfs(root->left);
	//如果左右小于0,则直接抛弃左右即可,也即赋值为0 
	if (left<0)left=0;
	int right=dfs(root->right);
	if(right<0)right=0;
	int val=root->val;
	//跟新答案 
	answer=max(answer,left+right+val);
	//返回左右最大+cur 
	return max(left,right)+val;
}
int maxPathSum(TreeNode* root) 
{
	 dfs(root);
     return answer;
}
};
```

### 4.[二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

![image-20201210205525646](https://gitee.com/zisuu/picture/raw/master/img/20201210205525.png)

![image-20201210205531854](https://gitee.com/zisuu/picture/raw/master/img/20201210205531.png)



## 二叉搜索树列题

### 1.地鼠安家

![image-20201208235416703](https://gitee.com/zisuu/picture/raw/master/img/20201208235416.png)

```
输入示例
5
-1 1 -1
1 2 3
-1 3 -1
2 4 5
-1 5 -1

输出:
3
```

**题目分析**

考点:BST,BST中序遍历递增

先构建一棵树,利用中序遍历判断该序列是否递增即可



## 线状树列题

https://leetcode-cn.com/problems/range-sum-query-mutable/solution/java-xian-duan-shu-lazyyou-hua-jie-shi-hen-xiang-x/

#### [307. 区域和检索 ](https://leetcode-cn.com/problems/range-sum-query-mutable/)

![image-20201203170758373](https://gitee.com/zisuu/picture/raw/master/img/20201203170758.png)

## 字典树列题











