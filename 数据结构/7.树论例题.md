## 一般树题目集

### 1.橙子树

![image-20201208232151760](https://gitee.com/zisuu/picture/raw/master/img/20201208232151.png)

```
5 2
1 2 1
2 3 2
3 4 2
4 5 1


输出:
7
```

**题目分析**

![image-20201208233503734](https://gitee.com/zisuu/picture/raw/master/img/20201208233503.png)

**算法选择**

这里选择用dijkstra求最大路径长度

**代码实现**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> ll;
const int MAXN=1e5+10;
vector<ll> graph[MAXN];
vector<int> dist(MAXN,0);
vector<int> vis(MAXN,0);
priority_queue<ll,vector<ll>,less<ll>> qu; //优先队列
int sumL=0;//总的边权
int maxL=0; //离源点最大长度
void add(int a,int b,int v){
	graph[a].push_back({b,v});
	graph[b].push_back({a,v});
	sumL+=v;
}
void dijkstra(int start)
{
	qu.push({0,start});
	while(!qu.empty())
	{
		int cur=qu.top().second;
		qu.pop();
		if (vis[cur])continue;
		vis[cur]=true;
		maxL=max(maxL,dist[cur]);
		//对每一个邻接边
		for(int i=0;i<graph[cur].size();i++)
		{
			ll child= graph[cur][i];
			if(!vis[child.first])
			{
				if(dist[cur]+child.second>dist[child.first])
				{
					dist[child.first]=dist[cur]+child.second;
					qu.push({dist[child.first],child.first});
				}
			}
		}
	}
}
int main()
{
	int n,start;
	cin>>n>>start;
	int a,b,v;
	for(int i=0;i<n-1;i++)
	{
		cin>>a>>b>>v;
		add(a,b,v);
	}
	dijkstra(start);
	cout<<sumL*2-maxL;
}

```

### 2.[不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

![image-20201210193431504](https://gitee.com/zisuu/picture/raw/master/img/20201210193431.png)

**题目分析**

本题主要考察dp,bst的性质

以i为根节点,则其左子树为[0,i-1],右子树为[i+1,n]

所以num[i]=dp[i-1]+dp[n-i] (i=0,1,2,....n);

dp边界是dp[0]=1

代码:

```c++
class Solution {
public:
int numTrees(int n) {
    vector<int> dp(n+1,0);
    dp[0]=1;
    for (int i = 1; i <=n ; ++i) {
        for(int j=1;j<=i;j++){
            dp[i]+=dp[j-1]*dp[i-j];
        }
    }
    return dp[n];
}
};
```



## 树的递归类型

### 0.[二叉树展开为链表⭐](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

![image-20201210201547921](https://gitee.com/zisuu/picture/raw/master/img/20201210201548.png)

**题目分析**

递归的常见思路:

- 相信一个函数,能提供将以root为根的树,展开为链表
- 于是我们可以借助此函数得到左右两根链表
- 最后变化一下即可
- 一定要把递归想象成一个抽象的过程,就当作我们已经有两根链表了,要做的无非是遍历到左边那根链表的最右边那个节点,然后把右边那根链表接上即可

```c++
class Solution {
public:
typedef TreeNode * node;
node dfs(node root){
    if(!root)return NULL;
    node left=dfs(root->left);
    node right=dfs(root->right);
    root->right=left;
    //遍历到最右边一个节点
    node temp=root;
    while(temp->right){
        temp=temp->right;
    }
    temp->right=right;
    root->left=NULL;
    return root;
}
void flatten(TreeNode* root) {
    dfs(root);
}
};
```

### 1.[验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

![image-20201210194838614](https://gitee.com/zisuu/picture/raw/master/img/20201210194838.png)

对于BST,无非左子树比当前小,右子树比当前大,逃不过这个性质,关于BST的都可以往这个方向套

所以,很容易得出递归的思路:

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
typedef TreeNode * node;
bool  dfs(node root,long lower,long upper){
    if(!root)return true;
    int val=root->val;
    if(val<=lower||val>=upper)return false;
    return dfs(root->left,lower,val)&&dfs(root->right,val,upper);

}
bool isValidBST(TreeNode* root) {
    return dfs(root,LONG_MIN,LONG_MAX);
}
};
```

### 2.[路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

![image-20201210201156416](https://gitee.com/zisuu/picture/raw/master/img/20201210201156.png)

**题目分析**

这是一道很常见的dfs回朔类型的题目

```c++
struct TreeNode{
	int val;
	TreeNode * left;
	TreeNode * right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
typedef TreeNode * node;
vector<vector<int>> result;
void dfs(node root,int cur,vector<int> arr)
{
	if(!root)return;
	int val=root->val;
	cur-=val;
	arr.push_back(val);
	if (!root->left&&!root->right&&cur==0)
	{
		result.push_back(arr);
		//注意回朔 
		arr.pop_back();
		return;
	}
	dfs(root->left,cur,arr);
	dfs(root->right,cur,arr);
			//注意回朔 
	arr.pop_back();
}
vector<vector<int>> pathSum(TreeNode* root, int sum) {
    dfs (root,sum,vector<int>{});
    return result;
}
```

### 3.[路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

![image-20201211150229362](https://gitee.com/zisuu/picture/raw/master/img/20201211150229.png)

**题目分析**

这个题目就是对每个顶点,有两种情况:

- 继承上一个顶点,查看当前的值是否和剩下的target相同
- 传递至左右顶点,在左右孩子中寻找路径

另外,dfs含义:

以当前根为顶点,寻找目标为sum的路径

dfs函数需要对每个顶点都调用一次

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
typedef TreeNode * node;
int dfs(node root,int sum){
    if(!root)return 0;
    int ans=0;
    int val=root->val;
    //当前点
    if(val==sum){
        ans++;
    }
    //左右
    ans+=dfs(root->left,sum-val);
    ans+=dfs(root->right,sum-val);
    return ans;
}
int pathSum(TreeNode* root, int sum) {
    if(!root)return 0;
    return dfs(root,sum)+pathSum(root->left,sum)+pathSum(root->right,sum);
}
};
```



### 3.[二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

![image-20201210204108512](https://gitee.com/zisuu/picture/raw/master/img/20201210204108.png)

![image-20201210204116338](https://gitee.com/zisuu/picture/raw/master/img/20201210204116.png)

**题目分析**

同样根据第一题的思路:

- 相信一个函数dfs,它可以返回以root为根节点的最大路径
- 也即我们就可以得到左右两颗树各自的最大路径,那对于当前节点root,其最大路径就是left+cur+right,并更新答案
- 但是返回的,是左右最大的路径+cur,而不是返回最大路径

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
typedef TreeNode * node;
int answer=INT_MIN;
int dfs(node root)
{
	if (!root)return 0;
	int left=dfs(root->left);
	//如果左右小于0,则直接抛弃左右即可,也即赋值为0 
	if (left<0)left=0;
	int right=dfs(root->right);
	if(right<0)right=0;
	int val=root->val;
	//跟新答案 
	answer=max(answer,left+right+val);
	//返回左右最大+cur 
	return max(left,right)+val;
}
int maxPathSum(TreeNode* root) 
{
	 dfs(root);
     return answer;
}
};
```

### 4.[二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

![image-20201210205525646](https://gitee.com/zisuu/picture/raw/master/img/20201210205525.png)

![image-20201210205531854](https://gitee.com/zisuu/picture/raw/master/img/20201210205531.png)

这种题目主要分清楚几种情况即可

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root)return NULL;
    //如果当前节点和p,q某一个相等,说明当前节点就是要找的点
    if (root==p||root==q)return root;
    //从左右中寻找
    node left=lowestCommonAncestor(root->left,p,q);
    node right=lowestCommonAncestor(root->right,p,q);
    //都不为空,说明p,q分散在左右中,当前为父节点
    if (left&&right)return root;
    else return left?left:right;
}
```

### 5.[打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

![image-20201211145043403](https://gitee.com/zisuu/picture/raw/master/img/20201211145043.png)

**题目分析**

这是一道递归+dp思想的题目

状态无非两个:

- 如果抢当前的节点,则左右孩子不能碰
- 不抢当前点,则可以碰左右孩子

接着,递归的思想,相信一个函数,其可以返回以一个root为根的点所能抢的最大佳值

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
typedef TreeNode * node;
//备忘录
map<node,int> dict;
int dfs(node root)
{
	if (!root) return 0;
	if(dict.find(root)!=dict.end())
		return dict[root];
	//如果抢当前点,则左右孩子点不能抢 
	int do_it= root->val;
	if(root->left)do_it+=dfs(root->left->left)+dfs(root->left->right);
	if(root->right)do_it+=dfs(root->right->left)+dfs(root->right->right);
	//不抢当前点,只能抢左右孩子点 
	int no_do=dfs(root->left)+dfs(root->right);	
	int result= max(do_it,no_do);
	dict[root]=result;
	return result;
} 
int rob(TreeNode* root) {
	return dfs(root);
}

};
```

### 6.[好叶子节点对的数量](https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/)

![image-20201211154025960](https://gitee.com/zisuu/picture/raw/master/img/20201211154026.png)

![image-20201211154034087](https://gitee.com/zisuu/picture/raw/master/img/20201211154034.png)

**题目分析**

基本思路如下:

- 找到当前节点的所有左右叶子节点距离当前节点的距离
- 对两个数组进行两两匹配,看是否在distance范围内

```c++
struct TreeNode{
	int val;
	TreeNode *left;
	TreeNode * right;
	TreeNode(int x):val(x),left(NULL),right(NULL){
	}
};
typedef TreeNode * node;
int ans=0;
vector<int> dfs(node root,int top){
	vector<int> result{};
	if(!root)return  result;
	//如果当前是叶子节点,就返回当前距离1 
	if(!root->left&&!root->right)
	{
		result.push_back(1);
		return result;
	} 
	//获取左右的叶子数组 
	vector<int> left=dfs(root->left,top);
	vector<int> right=dfs(root->right,top);;
	if(left.size()>0&&right.size()>0)
	{
		//两两匹配 
			for (auto l:left)
			{
				for (auto r:right)
				{
					if(l+r<=top)
					{
						ans++;
					}
				}
			}
	}
	//构建叶子数组 
	for(auto l:left)
	{
		if(l+1>top)continue;
		result.push_back(l+1);
	}
	for(auto r:right){
		if(r+1>top)continue;
		result.push_back(r+1);
	}
	return result;
}
int countPairs(TreeNode* root, int distance) {
	dfs(root,distance);
	return ans;   
}
```



## 二叉搜索树列题

### 1.地鼠安家

![image-20201208235416703](https://gitee.com/zisuu/picture/raw/master/img/20201208235416.png)

```
输入示例
5
-1 1 -1
1 2 3
-1 3 -1
2 4 5
-1 5 -1

输出:
3
```

**题目分析**

考点:BST,BST中序遍历递增

先构建一棵树,利用中序遍历判断该序列是否递增即可



## 线状树列题

### [1 区域和检索 ](https://leetcode-cn.com/problems/range-sum-query-mutable/)



![image-20201203170758373](https://gitee.com/zisuu/picture/raw/master/img/20201203170758.png)

模板题:

```c++
class NumArray {
public:
    #define ls k<<1
    #define  rs k<<1|1
    #define mid l+(r-l)/2;
    vector<int> lazy;
    vector<int> t;
    vector<int> nums;
    int size;
    NumArray(vector<int>& nums) {
        size=nums.size();
        if(size==0)
          return;
        lazy=vector<int>(size*4+1,0);
        t=vector<int>(size*4+1,0);
        this->nums=nums;
        build(1,0,size-1);
    }

    void update(int i, int val) {
        update_point(1,0,size-1,i,val);
    }

    int sumRange(int i, int j) {
        return query_range(1,0,size-1,i,j);
    }

    //////////////////////////////////////
    void pushUp(int k)
    {
        t[k]=t[ls]+t[rs];
    }
    void build(int k,int l,int r)
    {
        if(l==r)
        {
            t[k]=nums[l];
        }
        else
        {
            int m=mid;
            build(ls,l,m);
            build(rs,m+1,r);
            pushUp(k);
        }
    }
    void update_point(int k,int l,int r,int p,int v)
    {
        if(l==r)
        {
            t[k]=v;
        }
        else{
            int m=mid;
            if(p<=m)
                update_point(ls,l,m,p,v);
            if(p>m)
                update_point(rs,m+1,r,p,v);
            pushUp(k);
        }
    }
    int query_range(int k,int l,int r,int L,int R)
    {
        if (l>=L&&r<=R)
            return t[k];
        else
        {
           int ans=0;
           int m=mid;
           if(L<=m)
               ans+=query_range(ls,l,m,L,R);
           if(R>m)
               ans+=query_range(rs,m+1,r,L,R);
           return ans;
        }
    }

};
```

### 2.[区间和的个数](https://leetcode-cn.com/problems/count-of-range-sum/)

![image-20201212114259984](https://gitee.com/zisuu/picture/raw/master/img/20201212114300.png)



## 字典树列题











